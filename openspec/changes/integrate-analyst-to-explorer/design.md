## Context

The explorer Wails app currently provides schema visualization, graph exploration, and chat features. The analyst CLI tool exists separately and provides entity type analysis and promotion capabilities using `internal/analyst` and `internal/promoter` packages. The explorer app already has database connections (`*ent.Client` and `*sql.DB`) available via the `App` struct.

Wails apps expose backend methods to the frontend by binding Go methods on the `App` struct. Frontend components call these methods via TypeScript bindings generated by Wails.

**Current State:**
- `cmd/explorer/app.go` has existing Wails-bound methods (GetSchema, GetNodes, ProcessChatQuery, etc.)
- `internal/analyst` package provides `AnalyzeAndRankCandidates()` and `GenerateSchemaForType()`
- `internal/promoter` package provides `PromoteType()` workflow
- Frontend is React-based (in `cmd/explorer/frontend/`)

**Constraints:**
- Must reuse existing analyst/promoter logic (no reimplementation)
- Must fit Wails architecture pattern (Go methods + TypeScript bindings)
- Promotion requires both `*ent.Client` (for queries) and `*sql.DB` (for migrations)
- Must work within existing explorer UI/UX patterns

## Goals / Non-Goals

**Goals:**
- Add entity analysis capability to explorer backend
- Add entity promotion capability to explorer backend
- Create UI components for displaying ranked candidates and executing promotions
- Maintain separation of concerns (App struct orchestrates, analyst/promoter packages contain logic)
- Provide configurable thresholds for analysis (min occurrences, consistency, top N)

**Non-Goals:**
- Modifying analyst or promoter package logic
- CLI tool deprecation (both can coexist)
- Real-time updates or streaming results (synchronous operations are acceptable)
- Multi-step promotion wizard (single-step promotion with confirmation)

## Decisions

### 1. Backend Integration Pattern

**Decision:** Add two new Wails-bound methods to `App` struct: `AnalyzeEntities()` and `PromoteEntity()`

**Rationale:**
- Follows existing pattern in explorer (GetSchema, GetNodes, etc.)
- Wails automatically generates TypeScript bindings for these methods
- `App` struct already has required dependencies (`client *ent.Client`, `config *utils.Config`)
- Clean separation: App orchestrates, analyst/promoter provide logic

**Alternatives Considered:**
- Create a separate service struct (AnalystService) - rejected because it adds complexity without clear benefit
- Expose analyst package methods directly - rejected because App needs to manage context and dependencies

### 2. Database Connection for Promoter

**Decision:** Store `*sql.DB` reference in `App` struct and pass to promoter when needed

**Rationale:**
- Promoter needs raw SQL connection for data migration (already established pattern in CLI tool)
- `*sql.DB` is already available in `NewApp()` constructor
- Same approach as cmd/analyst/main.go (see `runPromote()`)

**Implementation:**
```go
type App struct {
    // existing fields...
    db *sql.DB  // Add this
}
```

**Alternatives Considered:**
- Open new connection each time - rejected due to connection overhead
- Use only ent.Client - rejected because promoter requires raw SQL for migrations

### 3. Frontend Components

**Decision:** Create two new React components:
- `EntityAnalysis.tsx` - Display ranked candidates with configurable filters
- `EntityPromotion.tsx` - Show promotion workflow and results

**Rationale:**
- Matches existing explorer component structure (Schema, Graph, Chat components)
- Separation of concerns (analysis vs promotion)
- Can be integrated into existing tab/navigation structure

**Alternatives Considered:**
- Single combined component - rejected because analysis and promotion are distinct workflows
- Modal dialogs only - rejected because full-page components provide better UX for complex data

### 4. API Design

**Decision:** Use structured request/response types for both operations

**Analysis API:**
```go
type AnalysisRequest struct {
    MinOccurrences int     `json:"minOccurrences"`
    MinConsistency float64 `json:"minConsistency"`
    TopN           int     `json:"topN"`
}

type AnalysisResponse struct {
    Candidates []TypeCandidate `json:"candidates"`
    TotalTypes int            `json:"totalTypes"`
}

func (a *App) AnalyzeEntities(req AnalysisRequest) (*AnalysisResponse, error)
```

**Promotion API:**
```go
type PromotionRequest struct {
    TypeName string `json:"typeName"`
}

type PromotionResponse struct {
    Success           bool   `json:"success"`
    SchemaFilePath    string `json:"schemaFilePath"`
    EntitiesMigrated  int    `json:"entitiesMigrated"`
    ValidationErrors  int    `json:"validationErrors"`
    Error             string `json:"error,omitempty"`
    Properties        []PropertyInfo `json:"properties"`
}

func (a *App) PromoteEntity(req PromotionRequest) (*PromotionResponse, error)
```

**Rationale:**
- Type safety on both Go and TypeScript sides
- Wails automatically marshals JSON
- Follows existing pattern (see `NodeFilter`, `GraphResponse`)
- Extensible (can add fields without breaking API)

**Alternatives Considered:**
- Primitive parameters only - rejected because multiple parameters are harder to manage
- Return raw analyst types - rejected because we need explorer-specific response structure

### 5. Error Handling

**Decision:** Return errors from Wails methods; let frontend handle user-facing messages

**Rationale:**
- Consistent with existing Wails methods in App
- Frontend can display errors in UI (toast notifications, error states)
- Go errors provide context for debugging

**Implementation:**
- Backend returns `error` as second return value
- Frontend catches errors in try-catch and displays appropriately

### 6. Project Root Handling

**Decision:** Calculate project root dynamically using `os.Getwd()` when needed for promotion

**Rationale:**
- Promoter requires project root for schema file generation
- Explorer runs from `cmd/explorer` directory, so we need to navigate up
- Same approach as CLI tool

**Implementation:**
```go
projectRoot, err := os.Getwd()
// Navigate to actual project root if needed
projectRoot = filepath.Join(projectRoot, "../..")
```

**Alternatives Considered:**
- Store project root in config - rejected because it's environment-dependent
- Hard-code path - rejected because it's not portable

### 7. Development Methodology

**Decision:** Implement using Test-Driven Development (TDD) - write tests before implementation

**Rationale:**
- New backend methods require precise behavior (data transformation, error handling)
- Tests serve as executable specifications for the Wails API contract
- Easier to mock analyst/promoter dependencies for isolated unit testing
- Prevents regression as features evolve
- Ensures all edge cases are considered before writing code

**Implementation approach:**
- Write unit tests first for each new App method (AnalyzeEntities, PromoteEntity)
- Mock analyst and promoter package calls to test App orchestration logic in isolation
- Test error handling paths (database failures, invalid inputs, boundary conditions)
- Then write implementation to make tests pass
- Integration tests verify end-to-end flow with test database

**Alternatives Considered:**
- Test-after approach - rejected because it often leads to untested edge cases and harder-to-test code
- No tests for Wails bindings - rejected because the binding layer makes manual testing tedious and error-prone

### 8. UI Integration Strategy

**Decision:** Add a new "Analyst" mode as a fourth primary view alongside Schema/Graph/Chat, accessed via navigation tabs in the header

**Current UI Structure:**
- Left sidebar: SchemaPanel (shows promoted/discovered types)
- Main content: FilterBar + GraphCanvas (visual graph exploration)
- Right sidebar: DetailPanel (shows selected node/type details)
- Bottom panel: ChatPanel (collapsible natural language queries)

**Proposed Integration:**
- Add **navigation tabs** in app header: "Graph" (default) | "Schema Analyst"
- **Graph mode** (existing): Shows schema sidebar + graph canvas + detail panel + chat panel
- **Analyst mode** (new): Shows analysis interface with two sections:
  - **EntityAnalysis component** (top/main area):
    - Configuration controls (min occurrences, consistency threshold, top N)
    - "Analyze" button to trigger analysis
    - Results table showing ranked candidates with sortable columns
    - Click candidate to view details or promote
  - **EntityPromotion component** (right sidebar or modal):
    - Triggered when "Promote" clicked on a candidate
    - Shows type name, detected properties, preview of schema
    - Confirmation flow before execution
    - Progress indicator during promotion
    - Results summary (success/error, files created, entities migrated)

**Layout for Schema Analyst Mode:**
```
┌──────────────────────────────────────────────────────────────┐
│ Header: Graph | [Schema Analyst]                             │
├──────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌────────────────────────────────┐ ┌────────────────────┐  │
│  │ EntityAnalysis                 │ │ EntityPromotion    │  │
│  │                                │ │ (when triggered)   │  │
│  │ [Config Panel]                 │ │                    │  │
│  │ Min Occurrences: [5]           │ │ Type: Person       │  │
│  │ Consistency: [40%]             │ │                    │  │
│  │ Top N: [10]      [Analyze]     │ │ Properties:        │  │
│  │                                │ │ - name: string ✓   │  │
│  │ [Results Table]                │ │ - email: string ✓  │  │
│  │ Rank │ Type    │ Score │ ...   │ │                    │  │
│  │ 1    │ Person  │ 0.85  │[View] │ │ [Cancel][Promote]  │  │
│  │ 2    │ Company │ 0.72  │[View] │ │                    │  │
│  │ ...                            │ │                    │  │
│  └────────────────────────────────┘ └────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
```

**Rationale:**
- Tab-based navigation is familiar pattern (vs adding to existing sidebar which is already dense)
- Analyst workflow is distinct from graph exploration - deserves dedicated space
- Keeps graph view clean and focused on visualization
- Promotion is infrequent action - sidebar/modal is sufficient (doesn't need full-page)
- Reuses existing UI patterns (ErrorBoundary, LoadingSkeleton, error handling)

**Implementation Details:**
- Add state to App.tsx: `const [activeView, setActiveView] = useState<'graph' | 'analyst'>('graph')`
- Conditionally render based on activeView:
  ```tsx
  {activeView === 'graph' && <GraphView />}
  {activeView === 'analyst' && <AnalystView />}
  ```
- EntityAnalysis maintains its own state (config, results, loading, error)
- EntityPromotion can be modal or slide-in panel (decide during implementation)
- After successful promotion, show toast notification and offer to refresh schema

**Alternatives Considered:**
- Add "Analyze" button to SchemaPanel - rejected because it clutters existing schema view and doesn't provide space for configuration/results
- Modal-only approach for all analyst features - rejected because modal is poor UX for complex data tables
- Integrate into existing graph view - rejected because analyst workflow is conceptually different from graph exploration
- Separate window/route - rejected because Wails apps typically use single-page approach

**Integration with Existing Features:**
- After promotion, trigger `handleRefreshSchema()` to update SchemaPanel
- Clicking promoted type in results can switch to Graph view and highlight that type
- Chat can suggest "analyze entities" as a discoverable action

## Risks / Trade-offs

**[Risk]** Promotion is a blocking operation that modifies filesystem and database  
**→ Mitigation:** Display loading state in UI, show clear confirmation before promotion, provide detailed error messages on failure

**[Risk]** Large datasets could make analysis slow (>10s)  
**→ Mitigation:** Add timeout to frontend (60s), show progress indicator, document performance characteristics in UI

**[Risk]** Concurrent promotions could conflict (file writes)  
**→ Mitigation:** Disable promotion button while operation in progress, show clear "in progress" state

**[Risk]** Frontend TypeScript bindings may need regeneration after adding new methods  
**→ Mitigation:** Document requirement to run `wails dev` or `wails build` to regenerate bindings

**[Trade-off]** Synchronous operations vs streaming results  
**→ Decision:** Accept synchronous for simplicity. Analysis typically completes in <5s, promotion in <10s. Streaming adds complexity without clear user benefit for these timescales.

**[Trade-off]** Error messages in backend vs frontend  
**→ Decision:** Backend returns technical errors, frontend formats user-friendly messages. Provides flexibility and keeps backend reusable.

## Migration Plan

**Development (TDD approach):**
1. Add `db *sql.DB` field to App struct
2. **Write tests** for `AnalyzeEntities()` method (mock analyst package)
3. **Implement** `AnalyzeEntities()` until tests pass
4. **Write tests** for `PromoteEntity()` method (mock promoter package)
5. **Implement** `PromoteEntity()` until tests pass
6. Create React components and integrate with Wails bindings
7. Add navigation/tabs for new features

**Testing:**
- **Unit tests** (write first, before implementation):
  - AnalyzeEntities: parameter validation, analyst package integration, error handling
  - PromoteEntity: type name validation, promoter integration, project root calculation
  - Mock analyst.AnalyzeAndRankCandidates and promoter.PromoteType
- **Integration tests** with test database:
  - End-to-end analysis flow with real database
  - End-to-end promotion flow (may need cleanup after)
- **Manual testing** in Wails dev mode for UI/UX validation

**Deployment:**
- No database migrations needed (uses existing tables)
- No breaking changes to existing features
- New features are additive only

**Rollback:**
- Remove new methods from App struct
- Remove new frontend components
- No data migration needed (nothing persisted by new features)
