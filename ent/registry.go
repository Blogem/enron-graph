// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/Blogem/enron-graph/internal/registry"
)

// createDiscoveredEntity creates a DiscoveredEntity entity from a property map.
//
// This function is called by the extractor when routing entities to promoted schemas.
// It extracts the Ent client from the context and maps properties from the data map
// to the appropriate Ent builder setter methods.
//
// Supported field types: string, int, float64, bool
// TODO: Add support for edge/relationship fields, JSON fields, and time fields
func createDiscoveredEntity(ctx context.Context, data map[string]any) (any, error) {
	// Extract Ent client from context
	client, ok := ctx.Value("entClient").(*Client)
	if !ok || client == nil {
		return nil, fmt.Errorf("ent client not found in context")
	}

	// Create builder
	builder := client.DiscoveredEntity.Create()

	if val, ok := data["unique_id"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetUniqueID(strVal)
		}
	}

	if val, ok := data["type_category"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetTypeCategory(strVal)
		}
	}

	if val, ok := data["name"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetName(strVal)
		}
	}

	if val, ok := data["confidence_score"]; ok && val != nil {
		if floatVal, ok := val.(float64); ok {
			builder.SetConfidenceScore(floatVal)
		}
	}

	// Save the entity
	entity, err := builder.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create DiscoveredEntity: %w", err)
	}

	return entity, nil
}

// createEmail creates a Email entity from a property map.
//
// This function is called by the extractor when routing entities to promoted schemas.
// It extracts the Ent client from the context and maps properties from the data map
// to the appropriate Ent builder setter methods.
//
// Supported field types: string, int, float64, bool
// TODO: Add support for edge/relationship fields, JSON fields, and time fields
func createEmail(ctx context.Context, data map[string]any) (any, error) {
	// Extract Ent client from context
	client, ok := ctx.Value("entClient").(*Client)
	if !ok || client == nil {
		return nil, fmt.Errorf("ent client not found in context")
	}

	// Create builder
	builder := client.Email.Create()

	if val, ok := data["message_id"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetMessageID(strVal)
		}
	}

	if val, ok := data["from"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetFrom(strVal)
		}
	}

	if val, ok := data["subject"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetSubject(strVal)
		}
	}

	if val, ok := data["body"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetBody(strVal)
		}
	}

	if val, ok := data["file_path"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetFilePath(strVal)
		}
	}

	// Save the entity
	entity, err := builder.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create Email: %w", err)
	}

	return entity, nil
}

// createRelationship creates a Relationship entity from a property map.
//
// This function is called by the extractor when routing entities to promoted schemas.
// It extracts the Ent client from the context and maps properties from the data map
// to the appropriate Ent builder setter methods.
//
// Supported field types: string, int, float64, bool
// TODO: Add support for edge/relationship fields, JSON fields, and time fields
func createRelationship(ctx context.Context, data map[string]any) (any, error) {
	// Extract Ent client from context
	client, ok := ctx.Value("entClient").(*Client)
	if !ok || client == nil {
		return nil, fmt.Errorf("ent client not found in context")
	}

	// Create builder
	builder := client.Relationship.Create()

	if val, ok := data["type"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetType(strVal)
		}
	}

	if val, ok := data["from_type"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetFromType(strVal)
		}
	}

	if val, ok := data["from_id"]; ok && val != nil {
		if intVal, ok := val.(int); ok {
			builder.SetFromID(intVal)
		}
	}

	if val, ok := data["to_type"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetToType(strVal)
		}
	}

	if val, ok := data["to_id"]; ok && val != nil {
		if intVal, ok := val.(int); ok {
			builder.SetToID(intVal)
		}
	}

	if val, ok := data["confidence_score"]; ok && val != nil {
		if floatVal, ok := val.(float64); ok {
			builder.SetConfidenceScore(floatVal)
		}
	}

	// Save the entity
	entity, err := builder.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create Relationship: %w", err)
	}

	return entity, nil
}

// createSchemaPromotion creates a SchemaPromotion entity from a property map.
//
// This function is called by the extractor when routing entities to promoted schemas.
// It extracts the Ent client from the context and maps properties from the data map
// to the appropriate Ent builder setter methods.
//
// Supported field types: string, int, float64, bool
// TODO: Add support for edge/relationship fields, JSON fields, and time fields
func createSchemaPromotion(ctx context.Context, data map[string]any) (any, error) {
	// Extract Ent client from context
	client, ok := ctx.Value("entClient").(*Client)
	if !ok || client == nil {
		return nil, fmt.Errorf("ent client not found in context")
	}

	// Create builder
	builder := client.SchemaPromotion.Create()

	if val, ok := data["type_name"]; ok && val != nil {
		if strVal, ok := val.(string); ok {
			builder.SetTypeName(strVal)
		}
	}

	if val, ok := data["entities_affected"]; ok && val != nil {
		if intVal, ok := val.(int); ok {
			builder.SetEntitiesAffected(intVal)
		}
	}

	if val, ok := data["validation_failures"]; ok && val != nil {
		if intVal, ok := val.(int); ok {
			builder.SetValidationFailures(intVal)
		}
	}

	// Save the entity
	entity, err := builder.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create SchemaPromotion: %w", err)
	}

	return entity, nil
}

// init registers all Ent schemas with the promoted types registry.
// This function runs automatically at application startup, populating the
// global registry with EntityCreator functions for each schema.
//
// The registry enables the extractor to route discovered entities to their
// promoted schemas instead of always using the generic DiscoveredEntity table.
func init() {

	registry.Register("DiscoveredEntity", createDiscoveredEntity)

	registry.Register("Email", createEmail)

	registry.Register("Relationship", createRelationship)

	registry.Register("SchemaPromotion", createSchemaPromotion)

}
