// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Blogem/enron-graph/ent/discoveredentity"
	"github.com/Blogem/enron-graph/ent/email"
	"github.com/Blogem/enron-graph/ent/predicate"
	"github.com/Blogem/enron-graph/ent/relationship"
	"github.com/Blogem/enron-graph/ent/schemapromotion"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDiscoveredEntity = "DiscoveredEntity"
	TypeEmail            = "Email"
	TypeRelationship     = "Relationship"
	TypeSchemaPromotion  = "SchemaPromotion"
)

// DiscoveredEntityMutation represents an operation that mutates the DiscoveredEntity nodes in the graph.
type DiscoveredEntityMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	unique_id           *string
	type_category       *string
	name                *string
	properties          *map[string]interface{}
	embedding           *[]float32
	appendembedding     []float32
	confidence_score    *float64
	addconfidence_score *float64
	created_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*DiscoveredEntity, error)
	predicates          []predicate.DiscoveredEntity
}

var _ ent.Mutation = (*DiscoveredEntityMutation)(nil)

// discoveredentityOption allows management of the mutation configuration using functional options.
type discoveredentityOption func(*DiscoveredEntityMutation)

// newDiscoveredEntityMutation creates new mutation for the DiscoveredEntity entity.
func newDiscoveredEntityMutation(c config, op Op, opts ...discoveredentityOption) *DiscoveredEntityMutation {
	m := &DiscoveredEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscoveredEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscoveredEntityID sets the ID field of the mutation.
func withDiscoveredEntityID(id int) discoveredentityOption {
	return func(m *DiscoveredEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscoveredEntity
		)
		m.oldValue = func(ctx context.Context) (*DiscoveredEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscoveredEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscoveredEntity sets the old DiscoveredEntity of the mutation.
func withDiscoveredEntity(node *DiscoveredEntity) discoveredentityOption {
	return func(m *DiscoveredEntityMutation) {
		m.oldValue = func(context.Context) (*DiscoveredEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscoveredEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscoveredEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscoveredEntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscoveredEntityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscoveredEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUniqueID sets the "unique_id" field.
func (m *DiscoveredEntityMutation) SetUniqueID(s string) {
	m.unique_id = &s
}

// UniqueID returns the value of the "unique_id" field in the mutation.
func (m *DiscoveredEntityMutation) UniqueID() (r string, exists bool) {
	v := m.unique_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueID returns the old "unique_id" field's value of the DiscoveredEntity entity.
// If the DiscoveredEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveredEntityMutation) OldUniqueID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueID: %w", err)
	}
	return oldValue.UniqueID, nil
}

// ResetUniqueID resets all changes to the "unique_id" field.
func (m *DiscoveredEntityMutation) ResetUniqueID() {
	m.unique_id = nil
}

// SetTypeCategory sets the "type_category" field.
func (m *DiscoveredEntityMutation) SetTypeCategory(s string) {
	m.type_category = &s
}

// TypeCategory returns the value of the "type_category" field in the mutation.
func (m *DiscoveredEntityMutation) TypeCategory() (r string, exists bool) {
	v := m.type_category
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCategory returns the old "type_category" field's value of the DiscoveredEntity entity.
// If the DiscoveredEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveredEntityMutation) OldTypeCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCategory: %w", err)
	}
	return oldValue.TypeCategory, nil
}

// ResetTypeCategory resets all changes to the "type_category" field.
func (m *DiscoveredEntityMutation) ResetTypeCategory() {
	m.type_category = nil
}

// SetName sets the "name" field.
func (m *DiscoveredEntityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DiscoveredEntityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DiscoveredEntity entity.
// If the DiscoveredEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveredEntityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DiscoveredEntityMutation) ResetName() {
	m.name = nil
}

// SetProperties sets the "properties" field.
func (m *DiscoveredEntityMutation) SetProperties(value map[string]interface{}) {
	m.properties = &value
}

// Properties returns the value of the "properties" field in the mutation.
func (m *DiscoveredEntityMutation) Properties() (r map[string]interface{}, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the DiscoveredEntity entity.
// If the DiscoveredEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveredEntityMutation) OldProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// ClearProperties clears the value of the "properties" field.
func (m *DiscoveredEntityMutation) ClearProperties() {
	m.properties = nil
	m.clearedFields[discoveredentity.FieldProperties] = struct{}{}
}

// PropertiesCleared returns if the "properties" field was cleared in this mutation.
func (m *DiscoveredEntityMutation) PropertiesCleared() bool {
	_, ok := m.clearedFields[discoveredentity.FieldProperties]
	return ok
}

// ResetProperties resets all changes to the "properties" field.
func (m *DiscoveredEntityMutation) ResetProperties() {
	m.properties = nil
	delete(m.clearedFields, discoveredentity.FieldProperties)
}

// SetEmbedding sets the "embedding" field.
func (m *DiscoveredEntityMutation) SetEmbedding(f []float32) {
	m.embedding = &f
	m.appendembedding = nil
}

// Embedding returns the value of the "embedding" field in the mutation.
func (m *DiscoveredEntityMutation) Embedding() (r []float32, exists bool) {
	v := m.embedding
	if v == nil {
		return
	}
	return *v, true
}

// OldEmbedding returns the old "embedding" field's value of the DiscoveredEntity entity.
// If the DiscoveredEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveredEntityMutation) OldEmbedding(ctx context.Context) (v []float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmbedding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmbedding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmbedding: %w", err)
	}
	return oldValue.Embedding, nil
}

// AppendEmbedding adds f to the "embedding" field.
func (m *DiscoveredEntityMutation) AppendEmbedding(f []float32) {
	m.appendembedding = append(m.appendembedding, f...)
}

// AppendedEmbedding returns the list of values that were appended to the "embedding" field in this mutation.
func (m *DiscoveredEntityMutation) AppendedEmbedding() ([]float32, bool) {
	if len(m.appendembedding) == 0 {
		return nil, false
	}
	return m.appendembedding, true
}

// ClearEmbedding clears the value of the "embedding" field.
func (m *DiscoveredEntityMutation) ClearEmbedding() {
	m.embedding = nil
	m.appendembedding = nil
	m.clearedFields[discoveredentity.FieldEmbedding] = struct{}{}
}

// EmbeddingCleared returns if the "embedding" field was cleared in this mutation.
func (m *DiscoveredEntityMutation) EmbeddingCleared() bool {
	_, ok := m.clearedFields[discoveredentity.FieldEmbedding]
	return ok
}

// ResetEmbedding resets all changes to the "embedding" field.
func (m *DiscoveredEntityMutation) ResetEmbedding() {
	m.embedding = nil
	m.appendembedding = nil
	delete(m.clearedFields, discoveredentity.FieldEmbedding)
}

// SetConfidenceScore sets the "confidence_score" field.
func (m *DiscoveredEntityMutation) SetConfidenceScore(f float64) {
	m.confidence_score = &f
	m.addconfidence_score = nil
}

// ConfidenceScore returns the value of the "confidence_score" field in the mutation.
func (m *DiscoveredEntityMutation) ConfidenceScore() (r float64, exists bool) {
	v := m.confidence_score
	if v == nil {
		return
	}
	return *v, true
}

// OldConfidenceScore returns the old "confidence_score" field's value of the DiscoveredEntity entity.
// If the DiscoveredEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveredEntityMutation) OldConfidenceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfidenceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfidenceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfidenceScore: %w", err)
	}
	return oldValue.ConfidenceScore, nil
}

// AddConfidenceScore adds f to the "confidence_score" field.
func (m *DiscoveredEntityMutation) AddConfidenceScore(f float64) {
	if m.addconfidence_score != nil {
		*m.addconfidence_score += f
	} else {
		m.addconfidence_score = &f
	}
}

// AddedConfidenceScore returns the value that was added to the "confidence_score" field in this mutation.
func (m *DiscoveredEntityMutation) AddedConfidenceScore() (r float64, exists bool) {
	v := m.addconfidence_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfidenceScore resets all changes to the "confidence_score" field.
func (m *DiscoveredEntityMutation) ResetConfidenceScore() {
	m.confidence_score = nil
	m.addconfidence_score = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DiscoveredEntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiscoveredEntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DiscoveredEntity entity.
// If the DiscoveredEntity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveredEntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiscoveredEntityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the DiscoveredEntityMutation builder.
func (m *DiscoveredEntityMutation) Where(ps ...predicate.DiscoveredEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscoveredEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscoveredEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscoveredEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscoveredEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscoveredEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscoveredEntity).
func (m *DiscoveredEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscoveredEntityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.unique_id != nil {
		fields = append(fields, discoveredentity.FieldUniqueID)
	}
	if m.type_category != nil {
		fields = append(fields, discoveredentity.FieldTypeCategory)
	}
	if m.name != nil {
		fields = append(fields, discoveredentity.FieldName)
	}
	if m.properties != nil {
		fields = append(fields, discoveredentity.FieldProperties)
	}
	if m.embedding != nil {
		fields = append(fields, discoveredentity.FieldEmbedding)
	}
	if m.confidence_score != nil {
		fields = append(fields, discoveredentity.FieldConfidenceScore)
	}
	if m.created_at != nil {
		fields = append(fields, discoveredentity.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscoveredEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discoveredentity.FieldUniqueID:
		return m.UniqueID()
	case discoveredentity.FieldTypeCategory:
		return m.TypeCategory()
	case discoveredentity.FieldName:
		return m.Name()
	case discoveredentity.FieldProperties:
		return m.Properties()
	case discoveredentity.FieldEmbedding:
		return m.Embedding()
	case discoveredentity.FieldConfidenceScore:
		return m.ConfidenceScore()
	case discoveredentity.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscoveredEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discoveredentity.FieldUniqueID:
		return m.OldUniqueID(ctx)
	case discoveredentity.FieldTypeCategory:
		return m.OldTypeCategory(ctx)
	case discoveredentity.FieldName:
		return m.OldName(ctx)
	case discoveredentity.FieldProperties:
		return m.OldProperties(ctx)
	case discoveredentity.FieldEmbedding:
		return m.OldEmbedding(ctx)
	case discoveredentity.FieldConfidenceScore:
		return m.OldConfidenceScore(ctx)
	case discoveredentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DiscoveredEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveredEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discoveredentity.FieldUniqueID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueID(v)
		return nil
	case discoveredentity.FieldTypeCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCategory(v)
		return nil
	case discoveredentity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case discoveredentity.FieldProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case discoveredentity.FieldEmbedding:
		v, ok := value.([]float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmbedding(v)
		return nil
	case discoveredentity.FieldConfidenceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfidenceScore(v)
		return nil
	case discoveredentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DiscoveredEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscoveredEntityMutation) AddedFields() []string {
	var fields []string
	if m.addconfidence_score != nil {
		fields = append(fields, discoveredentity.FieldConfidenceScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscoveredEntityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case discoveredentity.FieldConfidenceScore:
		return m.AddedConfidenceScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveredEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case discoveredentity.FieldConfidenceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfidenceScore(v)
		return nil
	}
	return fmt.Errorf("unknown DiscoveredEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscoveredEntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(discoveredentity.FieldProperties) {
		fields = append(fields, discoveredentity.FieldProperties)
	}
	if m.FieldCleared(discoveredentity.FieldEmbedding) {
		fields = append(fields, discoveredentity.FieldEmbedding)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscoveredEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscoveredEntityMutation) ClearField(name string) error {
	switch name {
	case discoveredentity.FieldProperties:
		m.ClearProperties()
		return nil
	case discoveredentity.FieldEmbedding:
		m.ClearEmbedding()
		return nil
	}
	return fmt.Errorf("unknown DiscoveredEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscoveredEntityMutation) ResetField(name string) error {
	switch name {
	case discoveredentity.FieldUniqueID:
		m.ResetUniqueID()
		return nil
	case discoveredentity.FieldTypeCategory:
		m.ResetTypeCategory()
		return nil
	case discoveredentity.FieldName:
		m.ResetName()
		return nil
	case discoveredentity.FieldProperties:
		m.ResetProperties()
		return nil
	case discoveredentity.FieldEmbedding:
		m.ResetEmbedding()
		return nil
	case discoveredentity.FieldConfidenceScore:
		m.ResetConfidenceScore()
		return nil
	case discoveredentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DiscoveredEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscoveredEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscoveredEntityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscoveredEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscoveredEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscoveredEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscoveredEntityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscoveredEntityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DiscoveredEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscoveredEntityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DiscoveredEntity edge %s", name)
}

// EmailMutation represents an operation that mutates the Email nodes in the graph.
type EmailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	message_id    *string
	from          *string
	to            *[]string
	appendto      []string
	cc            *[]string
	appendcc      []string
	bcc           *[]string
	appendbcc     []string
	subject       *string
	date          *time.Time
	body          *string
	file_path     *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Email, error)
	predicates    []predicate.Email
}

var _ ent.Mutation = (*EmailMutation)(nil)

// emailOption allows management of the mutation configuration using functional options.
type emailOption func(*EmailMutation)

// newEmailMutation creates new mutation for the Email entity.
func newEmailMutation(c config, op Op, opts ...emailOption) *EmailMutation {
	m := &EmailMutation{
		config:        c,
		op:            op,
		typ:           TypeEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailID sets the ID field of the mutation.
func withEmailID(id int) emailOption {
	return func(m *EmailMutation) {
		var (
			err   error
			once  sync.Once
			value *Email
		)
		m.oldValue = func(ctx context.Context) (*Email, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Email.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmail sets the old Email of the mutation.
func withEmail(node *Email) emailOption {
	return func(m *EmailMutation) {
		m.oldValue = func(context.Context) (*Email, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Email.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessageID sets the "message_id" field.
func (m *EmailMutation) SetMessageID(s string) {
	m.message_id = &s
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *EmailMutation) MessageID() (r string, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldMessageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *EmailMutation) ResetMessageID() {
	m.message_id = nil
}

// SetFrom sets the "from" field.
func (m *EmailMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *EmailMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *EmailMutation) ResetFrom() {
	m.from = nil
}

// SetTo sets the "to" field.
func (m *EmailMutation) SetTo(s []string) {
	m.to = &s
	m.appendto = nil
}

// To returns the value of the "to" field in the mutation.
func (m *EmailMutation) To() (r []string, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldTo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// AppendTo adds s to the "to" field.
func (m *EmailMutation) AppendTo(s []string) {
	m.appendto = append(m.appendto, s...)
}

// AppendedTo returns the list of values that were appended to the "to" field in this mutation.
func (m *EmailMutation) AppendedTo() ([]string, bool) {
	if len(m.appendto) == 0 {
		return nil, false
	}
	return m.appendto, true
}

// ClearTo clears the value of the "to" field.
func (m *EmailMutation) ClearTo() {
	m.to = nil
	m.appendto = nil
	m.clearedFields[email.FieldTo] = struct{}{}
}

// ToCleared returns if the "to" field was cleared in this mutation.
func (m *EmailMutation) ToCleared() bool {
	_, ok := m.clearedFields[email.FieldTo]
	return ok
}

// ResetTo resets all changes to the "to" field.
func (m *EmailMutation) ResetTo() {
	m.to = nil
	m.appendto = nil
	delete(m.clearedFields, email.FieldTo)
}

// SetCc sets the "cc" field.
func (m *EmailMutation) SetCc(s []string) {
	m.cc = &s
	m.appendcc = nil
}

// Cc returns the value of the "cc" field in the mutation.
func (m *EmailMutation) Cc() (r []string, exists bool) {
	v := m.cc
	if v == nil {
		return
	}
	return *v, true
}

// OldCc returns the old "cc" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCc: %w", err)
	}
	return oldValue.Cc, nil
}

// AppendCc adds s to the "cc" field.
func (m *EmailMutation) AppendCc(s []string) {
	m.appendcc = append(m.appendcc, s...)
}

// AppendedCc returns the list of values that were appended to the "cc" field in this mutation.
func (m *EmailMutation) AppendedCc() ([]string, bool) {
	if len(m.appendcc) == 0 {
		return nil, false
	}
	return m.appendcc, true
}

// ClearCc clears the value of the "cc" field.
func (m *EmailMutation) ClearCc() {
	m.cc = nil
	m.appendcc = nil
	m.clearedFields[email.FieldCc] = struct{}{}
}

// CcCleared returns if the "cc" field was cleared in this mutation.
func (m *EmailMutation) CcCleared() bool {
	_, ok := m.clearedFields[email.FieldCc]
	return ok
}

// ResetCc resets all changes to the "cc" field.
func (m *EmailMutation) ResetCc() {
	m.cc = nil
	m.appendcc = nil
	delete(m.clearedFields, email.FieldCc)
}

// SetBcc sets the "bcc" field.
func (m *EmailMutation) SetBcc(s []string) {
	m.bcc = &s
	m.appendbcc = nil
}

// Bcc returns the value of the "bcc" field in the mutation.
func (m *EmailMutation) Bcc() (r []string, exists bool) {
	v := m.bcc
	if v == nil {
		return
	}
	return *v, true
}

// OldBcc returns the old "bcc" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldBcc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBcc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBcc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBcc: %w", err)
	}
	return oldValue.Bcc, nil
}

// AppendBcc adds s to the "bcc" field.
func (m *EmailMutation) AppendBcc(s []string) {
	m.appendbcc = append(m.appendbcc, s...)
}

// AppendedBcc returns the list of values that were appended to the "bcc" field in this mutation.
func (m *EmailMutation) AppendedBcc() ([]string, bool) {
	if len(m.appendbcc) == 0 {
		return nil, false
	}
	return m.appendbcc, true
}

// ClearBcc clears the value of the "bcc" field.
func (m *EmailMutation) ClearBcc() {
	m.bcc = nil
	m.appendbcc = nil
	m.clearedFields[email.FieldBcc] = struct{}{}
}

// BccCleared returns if the "bcc" field was cleared in this mutation.
func (m *EmailMutation) BccCleared() bool {
	_, ok := m.clearedFields[email.FieldBcc]
	return ok
}

// ResetBcc resets all changes to the "bcc" field.
func (m *EmailMutation) ResetBcc() {
	m.bcc = nil
	m.appendbcc = nil
	delete(m.clearedFields, email.FieldBcc)
}

// SetSubject sets the "subject" field.
func (m *EmailMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailMutation) ResetSubject() {
	m.subject = nil
}

// SetDate sets the "date" field.
func (m *EmailMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EmailMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *EmailMutation) ResetDate() {
	m.date = nil
}

// SetBody sets the "body" field.
func (m *EmailMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *EmailMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *EmailMutation) ResetBody() {
	m.body = nil
}

// SetFilePath sets the "file_path" field.
func (m *EmailMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *EmailMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ClearFilePath clears the value of the "file_path" field.
func (m *EmailMutation) ClearFilePath() {
	m.file_path = nil
	m.clearedFields[email.FieldFilePath] = struct{}{}
}

// FilePathCleared returns if the "file_path" field was cleared in this mutation.
func (m *EmailMutation) FilePathCleared() bool {
	_, ok := m.clearedFields[email.FieldFilePath]
	return ok
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *EmailMutation) ResetFilePath() {
	m.file_path = nil
	delete(m.clearedFields, email.FieldFilePath)
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the EmailMutation builder.
func (m *EmailMutation) Where(ps ...predicate.Email) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Email, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Email).
func (m *EmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.message_id != nil {
		fields = append(fields, email.FieldMessageID)
	}
	if m.from != nil {
		fields = append(fields, email.FieldFrom)
	}
	if m.to != nil {
		fields = append(fields, email.FieldTo)
	}
	if m.cc != nil {
		fields = append(fields, email.FieldCc)
	}
	if m.bcc != nil {
		fields = append(fields, email.FieldBcc)
	}
	if m.subject != nil {
		fields = append(fields, email.FieldSubject)
	}
	if m.date != nil {
		fields = append(fields, email.FieldDate)
	}
	if m.body != nil {
		fields = append(fields, email.FieldBody)
	}
	if m.file_path != nil {
		fields = append(fields, email.FieldFilePath)
	}
	if m.created_at != nil {
		fields = append(fields, email.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case email.FieldMessageID:
		return m.MessageID()
	case email.FieldFrom:
		return m.From()
	case email.FieldTo:
		return m.To()
	case email.FieldCc:
		return m.Cc()
	case email.FieldBcc:
		return m.Bcc()
	case email.FieldSubject:
		return m.Subject()
	case email.FieldDate:
		return m.Date()
	case email.FieldBody:
		return m.Body()
	case email.FieldFilePath:
		return m.FilePath()
	case email.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case email.FieldMessageID:
		return m.OldMessageID(ctx)
	case email.FieldFrom:
		return m.OldFrom(ctx)
	case email.FieldTo:
		return m.OldTo(ctx)
	case email.FieldCc:
		return m.OldCc(ctx)
	case email.FieldBcc:
		return m.OldBcc(ctx)
	case email.FieldSubject:
		return m.OldSubject(ctx)
	case email.FieldDate:
		return m.OldDate(ctx)
	case email.FieldBody:
		return m.OldBody(ctx)
	case email.FieldFilePath:
		return m.OldFilePath(ctx)
	case email.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Email field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case email.FieldMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case email.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case email.FieldTo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	case email.FieldCc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCc(v)
		return nil
	case email.FieldBcc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBcc(v)
		return nil
	case email.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case email.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case email.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case email.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case email.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Email numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(email.FieldTo) {
		fields = append(fields, email.FieldTo)
	}
	if m.FieldCleared(email.FieldCc) {
		fields = append(fields, email.FieldCc)
	}
	if m.FieldCleared(email.FieldBcc) {
		fields = append(fields, email.FieldBcc)
	}
	if m.FieldCleared(email.FieldFilePath) {
		fields = append(fields, email.FieldFilePath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailMutation) ClearField(name string) error {
	switch name {
	case email.FieldTo:
		m.ClearTo()
		return nil
	case email.FieldCc:
		m.ClearCc()
		return nil
	case email.FieldBcc:
		m.ClearBcc()
		return nil
	case email.FieldFilePath:
		m.ClearFilePath()
		return nil
	}
	return fmt.Errorf("unknown Email nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailMutation) ResetField(name string) error {
	switch name {
	case email.FieldMessageID:
		m.ResetMessageID()
		return nil
	case email.FieldFrom:
		m.ResetFrom()
		return nil
	case email.FieldTo:
		m.ResetTo()
		return nil
	case email.FieldCc:
		m.ResetCc()
		return nil
	case email.FieldBcc:
		m.ResetBcc()
		return nil
	case email.FieldSubject:
		m.ResetSubject()
		return nil
	case email.FieldDate:
		m.ResetDate()
		return nil
	case email.FieldBody:
		m.ResetBody()
		return nil
	case email.FieldFilePath:
		m.ResetFilePath()
		return nil
	case email.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Email unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Email edge %s", name)
}

// RelationshipMutation represents an operation that mutates the Relationship nodes in the graph.
type RelationshipMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_type               *string
	from_type           *string
	from_id             *int
	addfrom_id          *int
	to_type             *string
	to_id               *int
	addto_id            *int
	timestamp           *time.Time
	confidence_score    *float64
	addconfidence_score *float64
	properties          *map[string]interface{}
	created_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Relationship, error)
	predicates          []predicate.Relationship
}

var _ ent.Mutation = (*RelationshipMutation)(nil)

// relationshipOption allows management of the mutation configuration using functional options.
type relationshipOption func(*RelationshipMutation)

// newRelationshipMutation creates new mutation for the Relationship entity.
func newRelationshipMutation(c config, op Op, opts ...relationshipOption) *RelationshipMutation {
	m := &RelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRelationshipID sets the ID field of the mutation.
func withRelationshipID(id int) relationshipOption {
	return func(m *RelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Relationship
		)
		m.oldValue = func(ctx context.Context) (*Relationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Relationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelationship sets the old Relationship of the mutation.
func withRelationship(node *Relationship) relationshipOption {
	return func(m *RelationshipMutation) {
		m.oldValue = func(context.Context) (*Relationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Relationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *RelationshipMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RelationshipMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RelationshipMutation) ResetType() {
	m._type = nil
}

// SetFromType sets the "from_type" field.
func (m *RelationshipMutation) SetFromType(s string) {
	m.from_type = &s
}

// FromType returns the value of the "from_type" field in the mutation.
func (m *RelationshipMutation) FromType() (r string, exists bool) {
	v := m.from_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFromType returns the old "from_type" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldFromType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromType: %w", err)
	}
	return oldValue.FromType, nil
}

// ResetFromType resets all changes to the "from_type" field.
func (m *RelationshipMutation) ResetFromType() {
	m.from_type = nil
}

// SetFromID sets the "from_id" field.
func (m *RelationshipMutation) SetFromID(i int) {
	m.from_id = &i
	m.addfrom_id = nil
}

// FromID returns the value of the "from_id" field in the mutation.
func (m *RelationshipMutation) FromID() (r int, exists bool) {
	v := m.from_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromID returns the old "from_id" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldFromID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromID: %w", err)
	}
	return oldValue.FromID, nil
}

// AddFromID adds i to the "from_id" field.
func (m *RelationshipMutation) AddFromID(i int) {
	if m.addfrom_id != nil {
		*m.addfrom_id += i
	} else {
		m.addfrom_id = &i
	}
}

// AddedFromID returns the value that was added to the "from_id" field in this mutation.
func (m *RelationshipMutation) AddedFromID() (r int, exists bool) {
	v := m.addfrom_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromID resets all changes to the "from_id" field.
func (m *RelationshipMutation) ResetFromID() {
	m.from_id = nil
	m.addfrom_id = nil
}

// SetToType sets the "to_type" field.
func (m *RelationshipMutation) SetToType(s string) {
	m.to_type = &s
}

// ToType returns the value of the "to_type" field in the mutation.
func (m *RelationshipMutation) ToType() (r string, exists bool) {
	v := m.to_type
	if v == nil {
		return
	}
	return *v, true
}

// OldToType returns the old "to_type" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldToType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToType: %w", err)
	}
	return oldValue.ToType, nil
}

// ResetToType resets all changes to the "to_type" field.
func (m *RelationshipMutation) ResetToType() {
	m.to_type = nil
}

// SetToID sets the "to_id" field.
func (m *RelationshipMutation) SetToID(i int) {
	m.to_id = &i
	m.addto_id = nil
}

// ToID returns the value of the "to_id" field in the mutation.
func (m *RelationshipMutation) ToID() (r int, exists bool) {
	v := m.to_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToID returns the old "to_id" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldToID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToID: %w", err)
	}
	return oldValue.ToID, nil
}

// AddToID adds i to the "to_id" field.
func (m *RelationshipMutation) AddToID(i int) {
	if m.addto_id != nil {
		*m.addto_id += i
	} else {
		m.addto_id = &i
	}
}

// AddedToID returns the value that was added to the "to_id" field in this mutation.
func (m *RelationshipMutation) AddedToID() (r int, exists bool) {
	v := m.addto_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToID resets all changes to the "to_id" field.
func (m *RelationshipMutation) ResetToID() {
	m.to_id = nil
	m.addto_id = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *RelationshipMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *RelationshipMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *RelationshipMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetConfidenceScore sets the "confidence_score" field.
func (m *RelationshipMutation) SetConfidenceScore(f float64) {
	m.confidence_score = &f
	m.addconfidence_score = nil
}

// ConfidenceScore returns the value of the "confidence_score" field in the mutation.
func (m *RelationshipMutation) ConfidenceScore() (r float64, exists bool) {
	v := m.confidence_score
	if v == nil {
		return
	}
	return *v, true
}

// OldConfidenceScore returns the old "confidence_score" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldConfidenceScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfidenceScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfidenceScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfidenceScore: %w", err)
	}
	return oldValue.ConfidenceScore, nil
}

// AddConfidenceScore adds f to the "confidence_score" field.
func (m *RelationshipMutation) AddConfidenceScore(f float64) {
	if m.addconfidence_score != nil {
		*m.addconfidence_score += f
	} else {
		m.addconfidence_score = &f
	}
}

// AddedConfidenceScore returns the value that was added to the "confidence_score" field in this mutation.
func (m *RelationshipMutation) AddedConfidenceScore() (r float64, exists bool) {
	v := m.addconfidence_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfidenceScore resets all changes to the "confidence_score" field.
func (m *RelationshipMutation) ResetConfidenceScore() {
	m.confidence_score = nil
	m.addconfidence_score = nil
}

// SetProperties sets the "properties" field.
func (m *RelationshipMutation) SetProperties(value map[string]interface{}) {
	m.properties = &value
}

// Properties returns the value of the "properties" field in the mutation.
func (m *RelationshipMutation) Properties() (r map[string]interface{}, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// ClearProperties clears the value of the "properties" field.
func (m *RelationshipMutation) ClearProperties() {
	m.properties = nil
	m.clearedFields[relationship.FieldProperties] = struct{}{}
}

// PropertiesCleared returns if the "properties" field was cleared in this mutation.
func (m *RelationshipMutation) PropertiesCleared() bool {
	_, ok := m.clearedFields[relationship.FieldProperties]
	return ok
}

// ResetProperties resets all changes to the "properties" field.
func (m *RelationshipMutation) ResetProperties() {
	m.properties = nil
	delete(m.clearedFields, relationship.FieldProperties)
}

// SetCreatedAt sets the "created_at" field.
func (m *RelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the RelationshipMutation builder.
func (m *RelationshipMutation) Where(ps ...predicate.Relationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Relationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Relationship).
func (m *RelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RelationshipMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._type != nil {
		fields = append(fields, relationship.FieldType)
	}
	if m.from_type != nil {
		fields = append(fields, relationship.FieldFromType)
	}
	if m.from_id != nil {
		fields = append(fields, relationship.FieldFromID)
	}
	if m.to_type != nil {
		fields = append(fields, relationship.FieldToType)
	}
	if m.to_id != nil {
		fields = append(fields, relationship.FieldToID)
	}
	if m.timestamp != nil {
		fields = append(fields, relationship.FieldTimestamp)
	}
	if m.confidence_score != nil {
		fields = append(fields, relationship.FieldConfidenceScore)
	}
	if m.properties != nil {
		fields = append(fields, relationship.FieldProperties)
	}
	if m.created_at != nil {
		fields = append(fields, relationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case relationship.FieldType:
		return m.GetType()
	case relationship.FieldFromType:
		return m.FromType()
	case relationship.FieldFromID:
		return m.FromID()
	case relationship.FieldToType:
		return m.ToType()
	case relationship.FieldToID:
		return m.ToID()
	case relationship.FieldTimestamp:
		return m.Timestamp()
	case relationship.FieldConfidenceScore:
		return m.ConfidenceScore()
	case relationship.FieldProperties:
		return m.Properties()
	case relationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case relationship.FieldType:
		return m.OldType(ctx)
	case relationship.FieldFromType:
		return m.OldFromType(ctx)
	case relationship.FieldFromID:
		return m.OldFromID(ctx)
	case relationship.FieldToType:
		return m.OldToType(ctx)
	case relationship.FieldToID:
		return m.OldToID(ctx)
	case relationship.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case relationship.FieldConfidenceScore:
		return m.OldConfidenceScore(ctx)
	case relationship.FieldProperties:
		return m.OldProperties(ctx)
	case relationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Relationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case relationship.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case relationship.FieldFromType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromType(v)
		return nil
	case relationship.FieldFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromID(v)
		return nil
	case relationship.FieldToType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToType(v)
		return nil
	case relationship.FieldToID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToID(v)
		return nil
	case relationship.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case relationship.FieldConfidenceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfidenceScore(v)
		return nil
	case relationship.FieldProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case relationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Relationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RelationshipMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_id != nil {
		fields = append(fields, relationship.FieldFromID)
	}
	if m.addto_id != nil {
		fields = append(fields, relationship.FieldToID)
	}
	if m.addconfidence_score != nil {
		fields = append(fields, relationship.FieldConfidenceScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case relationship.FieldFromID:
		return m.AddedFromID()
	case relationship.FieldToID:
		return m.AddedToID()
	case relationship.FieldConfidenceScore:
		return m.AddedConfidenceScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case relationship.FieldFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromID(v)
		return nil
	case relationship.FieldToID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToID(v)
		return nil
	case relationship.FieldConfidenceScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfidenceScore(v)
		return nil
	}
	return fmt.Errorf("unknown Relationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(relationship.FieldProperties) {
		fields = append(fields, relationship.FieldProperties)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RelationshipMutation) ClearField(name string) error {
	switch name {
	case relationship.FieldProperties:
		m.ClearProperties()
		return nil
	}
	return fmt.Errorf("unknown Relationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RelationshipMutation) ResetField(name string) error {
	switch name {
	case relationship.FieldType:
		m.ResetType()
		return nil
	case relationship.FieldFromType:
		m.ResetFromType()
		return nil
	case relationship.FieldFromID:
		m.ResetFromID()
		return nil
	case relationship.FieldToType:
		m.ResetToType()
		return nil
	case relationship.FieldToID:
		m.ResetToID()
		return nil
	case relationship.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case relationship.FieldConfidenceScore:
		m.ResetConfidenceScore()
		return nil
	case relationship.FieldProperties:
		m.ResetProperties()
		return nil
	case relationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Relationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RelationshipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RelationshipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RelationshipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Relationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RelationshipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Relationship edge %s", name)
}

// SchemaPromotionMutation represents an operation that mutates the SchemaPromotion nodes in the graph.
type SchemaPromotionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	type_name              *string
	promoted_at            *time.Time
	promotion_criteria     *map[string]interface{}
	entities_affected      *int
	addentities_affected   *int
	validation_failures    *int
	addvalidation_failures *int
	schema_definition      *map[string]interface{}
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*SchemaPromotion, error)
	predicates             []predicate.SchemaPromotion
}

var _ ent.Mutation = (*SchemaPromotionMutation)(nil)

// schemapromotionOption allows management of the mutation configuration using functional options.
type schemapromotionOption func(*SchemaPromotionMutation)

// newSchemaPromotionMutation creates new mutation for the SchemaPromotion entity.
func newSchemaPromotionMutation(c config, op Op, opts ...schemapromotionOption) *SchemaPromotionMutation {
	m := &SchemaPromotionMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaPromotion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaPromotionID sets the ID field of the mutation.
func withSchemaPromotionID(id int) schemapromotionOption {
	return func(m *SchemaPromotionMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaPromotion
		)
		m.oldValue = func(ctx context.Context) (*SchemaPromotion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaPromotion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaPromotion sets the old SchemaPromotion of the mutation.
func withSchemaPromotion(node *SchemaPromotion) schemapromotionOption {
	return func(m *SchemaPromotionMutation) {
		m.oldValue = func(context.Context) (*SchemaPromotion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaPromotionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaPromotionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaPromotionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaPromotionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaPromotion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTypeName sets the "type_name" field.
func (m *SchemaPromotionMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *SchemaPromotionMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the SchemaPromotion entity.
// If the SchemaPromotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaPromotionMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *SchemaPromotionMutation) ResetTypeName() {
	m.type_name = nil
}

// SetPromotedAt sets the "promoted_at" field.
func (m *SchemaPromotionMutation) SetPromotedAt(t time.Time) {
	m.promoted_at = &t
}

// PromotedAt returns the value of the "promoted_at" field in the mutation.
func (m *SchemaPromotionMutation) PromotedAt() (r time.Time, exists bool) {
	v := m.promoted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotedAt returns the old "promoted_at" field's value of the SchemaPromotion entity.
// If the SchemaPromotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaPromotionMutation) OldPromotedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotedAt: %w", err)
	}
	return oldValue.PromotedAt, nil
}

// ResetPromotedAt resets all changes to the "promoted_at" field.
func (m *SchemaPromotionMutation) ResetPromotedAt() {
	m.promoted_at = nil
}

// SetPromotionCriteria sets the "promotion_criteria" field.
func (m *SchemaPromotionMutation) SetPromotionCriteria(value map[string]interface{}) {
	m.promotion_criteria = &value
}

// PromotionCriteria returns the value of the "promotion_criteria" field in the mutation.
func (m *SchemaPromotionMutation) PromotionCriteria() (r map[string]interface{}, exists bool) {
	v := m.promotion_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionCriteria returns the old "promotion_criteria" field's value of the SchemaPromotion entity.
// If the SchemaPromotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaPromotionMutation) OldPromotionCriteria(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotionCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotionCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionCriteria: %w", err)
	}
	return oldValue.PromotionCriteria, nil
}

// ClearPromotionCriteria clears the value of the "promotion_criteria" field.
func (m *SchemaPromotionMutation) ClearPromotionCriteria() {
	m.promotion_criteria = nil
	m.clearedFields[schemapromotion.FieldPromotionCriteria] = struct{}{}
}

// PromotionCriteriaCleared returns if the "promotion_criteria" field was cleared in this mutation.
func (m *SchemaPromotionMutation) PromotionCriteriaCleared() bool {
	_, ok := m.clearedFields[schemapromotion.FieldPromotionCriteria]
	return ok
}

// ResetPromotionCriteria resets all changes to the "promotion_criteria" field.
func (m *SchemaPromotionMutation) ResetPromotionCriteria() {
	m.promotion_criteria = nil
	delete(m.clearedFields, schemapromotion.FieldPromotionCriteria)
}

// SetEntitiesAffected sets the "entities_affected" field.
func (m *SchemaPromotionMutation) SetEntitiesAffected(i int) {
	m.entities_affected = &i
	m.addentities_affected = nil
}

// EntitiesAffected returns the value of the "entities_affected" field in the mutation.
func (m *SchemaPromotionMutation) EntitiesAffected() (r int, exists bool) {
	v := m.entities_affected
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitiesAffected returns the old "entities_affected" field's value of the SchemaPromotion entity.
// If the SchemaPromotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaPromotionMutation) OldEntitiesAffected(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitiesAffected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitiesAffected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitiesAffected: %w", err)
	}
	return oldValue.EntitiesAffected, nil
}

// AddEntitiesAffected adds i to the "entities_affected" field.
func (m *SchemaPromotionMutation) AddEntitiesAffected(i int) {
	if m.addentities_affected != nil {
		*m.addentities_affected += i
	} else {
		m.addentities_affected = &i
	}
}

// AddedEntitiesAffected returns the value that was added to the "entities_affected" field in this mutation.
func (m *SchemaPromotionMutation) AddedEntitiesAffected() (r int, exists bool) {
	v := m.addentities_affected
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntitiesAffected resets all changes to the "entities_affected" field.
func (m *SchemaPromotionMutation) ResetEntitiesAffected() {
	m.entities_affected = nil
	m.addentities_affected = nil
}

// SetValidationFailures sets the "validation_failures" field.
func (m *SchemaPromotionMutation) SetValidationFailures(i int) {
	m.validation_failures = &i
	m.addvalidation_failures = nil
}

// ValidationFailures returns the value of the "validation_failures" field in the mutation.
func (m *SchemaPromotionMutation) ValidationFailures() (r int, exists bool) {
	v := m.validation_failures
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationFailures returns the old "validation_failures" field's value of the SchemaPromotion entity.
// If the SchemaPromotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaPromotionMutation) OldValidationFailures(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationFailures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationFailures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationFailures: %w", err)
	}
	return oldValue.ValidationFailures, nil
}

// AddValidationFailures adds i to the "validation_failures" field.
func (m *SchemaPromotionMutation) AddValidationFailures(i int) {
	if m.addvalidation_failures != nil {
		*m.addvalidation_failures += i
	} else {
		m.addvalidation_failures = &i
	}
}

// AddedValidationFailures returns the value that was added to the "validation_failures" field in this mutation.
func (m *SchemaPromotionMutation) AddedValidationFailures() (r int, exists bool) {
	v := m.addvalidation_failures
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidationFailures resets all changes to the "validation_failures" field.
func (m *SchemaPromotionMutation) ResetValidationFailures() {
	m.validation_failures = nil
	m.addvalidation_failures = nil
}

// SetSchemaDefinition sets the "schema_definition" field.
func (m *SchemaPromotionMutation) SetSchemaDefinition(value map[string]interface{}) {
	m.schema_definition = &value
}

// SchemaDefinition returns the value of the "schema_definition" field in the mutation.
func (m *SchemaPromotionMutation) SchemaDefinition() (r map[string]interface{}, exists bool) {
	v := m.schema_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemaDefinition returns the old "schema_definition" field's value of the SchemaPromotion entity.
// If the SchemaPromotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaPromotionMutation) OldSchemaDefinition(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchemaDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchemaDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemaDefinition: %w", err)
	}
	return oldValue.SchemaDefinition, nil
}

// ClearSchemaDefinition clears the value of the "schema_definition" field.
func (m *SchemaPromotionMutation) ClearSchemaDefinition() {
	m.schema_definition = nil
	m.clearedFields[schemapromotion.FieldSchemaDefinition] = struct{}{}
}

// SchemaDefinitionCleared returns if the "schema_definition" field was cleared in this mutation.
func (m *SchemaPromotionMutation) SchemaDefinitionCleared() bool {
	_, ok := m.clearedFields[schemapromotion.FieldSchemaDefinition]
	return ok
}

// ResetSchemaDefinition resets all changes to the "schema_definition" field.
func (m *SchemaPromotionMutation) ResetSchemaDefinition() {
	m.schema_definition = nil
	delete(m.clearedFields, schemapromotion.FieldSchemaDefinition)
}

// Where appends a list predicates to the SchemaPromotionMutation builder.
func (m *SchemaPromotionMutation) Where(ps ...predicate.SchemaPromotion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaPromotionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaPromotionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaPromotion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaPromotionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaPromotionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaPromotion).
func (m *SchemaPromotionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaPromotionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.type_name != nil {
		fields = append(fields, schemapromotion.FieldTypeName)
	}
	if m.promoted_at != nil {
		fields = append(fields, schemapromotion.FieldPromotedAt)
	}
	if m.promotion_criteria != nil {
		fields = append(fields, schemapromotion.FieldPromotionCriteria)
	}
	if m.entities_affected != nil {
		fields = append(fields, schemapromotion.FieldEntitiesAffected)
	}
	if m.validation_failures != nil {
		fields = append(fields, schemapromotion.FieldValidationFailures)
	}
	if m.schema_definition != nil {
		fields = append(fields, schemapromotion.FieldSchemaDefinition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaPromotionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemapromotion.FieldTypeName:
		return m.TypeName()
	case schemapromotion.FieldPromotedAt:
		return m.PromotedAt()
	case schemapromotion.FieldPromotionCriteria:
		return m.PromotionCriteria()
	case schemapromotion.FieldEntitiesAffected:
		return m.EntitiesAffected()
	case schemapromotion.FieldValidationFailures:
		return m.ValidationFailures()
	case schemapromotion.FieldSchemaDefinition:
		return m.SchemaDefinition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaPromotionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemapromotion.FieldTypeName:
		return m.OldTypeName(ctx)
	case schemapromotion.FieldPromotedAt:
		return m.OldPromotedAt(ctx)
	case schemapromotion.FieldPromotionCriteria:
		return m.OldPromotionCriteria(ctx)
	case schemapromotion.FieldEntitiesAffected:
		return m.OldEntitiesAffected(ctx)
	case schemapromotion.FieldValidationFailures:
		return m.OldValidationFailures(ctx)
	case schemapromotion.FieldSchemaDefinition:
		return m.OldSchemaDefinition(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaPromotion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaPromotionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemapromotion.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case schemapromotion.FieldPromotedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotedAt(v)
		return nil
	case schemapromotion.FieldPromotionCriteria:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionCriteria(v)
		return nil
	case schemapromotion.FieldEntitiesAffected:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitiesAffected(v)
		return nil
	case schemapromotion.FieldValidationFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationFailures(v)
		return nil
	case schemapromotion.FieldSchemaDefinition:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemaDefinition(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaPromotion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaPromotionMutation) AddedFields() []string {
	var fields []string
	if m.addentities_affected != nil {
		fields = append(fields, schemapromotion.FieldEntitiesAffected)
	}
	if m.addvalidation_failures != nil {
		fields = append(fields, schemapromotion.FieldValidationFailures)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaPromotionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schemapromotion.FieldEntitiesAffected:
		return m.AddedEntitiesAffected()
	case schemapromotion.FieldValidationFailures:
		return m.AddedValidationFailures()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaPromotionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schemapromotion.FieldEntitiesAffected:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntitiesAffected(v)
		return nil
	case schemapromotion.FieldValidationFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidationFailures(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaPromotion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaPromotionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schemapromotion.FieldPromotionCriteria) {
		fields = append(fields, schemapromotion.FieldPromotionCriteria)
	}
	if m.FieldCleared(schemapromotion.FieldSchemaDefinition) {
		fields = append(fields, schemapromotion.FieldSchemaDefinition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaPromotionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaPromotionMutation) ClearField(name string) error {
	switch name {
	case schemapromotion.FieldPromotionCriteria:
		m.ClearPromotionCriteria()
		return nil
	case schemapromotion.FieldSchemaDefinition:
		m.ClearSchemaDefinition()
		return nil
	}
	return fmt.Errorf("unknown SchemaPromotion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaPromotionMutation) ResetField(name string) error {
	switch name {
	case schemapromotion.FieldTypeName:
		m.ResetTypeName()
		return nil
	case schemapromotion.FieldPromotedAt:
		m.ResetPromotedAt()
		return nil
	case schemapromotion.FieldPromotionCriteria:
		m.ResetPromotionCriteria()
		return nil
	case schemapromotion.FieldEntitiesAffected:
		m.ResetEntitiesAffected()
		return nil
	case schemapromotion.FieldValidationFailures:
		m.ResetValidationFailures()
		return nil
	case schemapromotion.FieldSchemaDefinition:
		m.ResetSchemaDefinition()
		return nil
	}
	return fmt.Errorf("unknown SchemaPromotion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaPromotionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaPromotionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaPromotionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaPromotionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaPromotionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaPromotionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaPromotionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaPromotion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaPromotionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaPromotion edge %s", name)
}
